    cd 'C:\Users\david\Desktop\GitHub\RBF-NS\src';
    % GA RBF
    HGA =  @(x,y,eps) [exp(1).^((-1).*eps.^2.*((x(1)+(-1).*y(1)).^2+(x(2)+(-1).*y(2)).^2+(x(3)+( ...
                    -1).*y(3)).^2)).*((-2).*eps.^2+4.*eps.^4.*(x(1)+(-1).*y(1)).^2),4.*exp( ...
                    1).^((-1).*eps.^2.*((x(1)+(-1).*y(1)).^2+(x(2)+(-1).*y(2)).^2+(x(3)+(-1).* ...
                    y(3)).^2)).*eps.^4.*(x(1)+(-1).*y(1)).*(x(2)+(-1).*y(2)),4.*exp(1).^((-1).* ...
                    eps.^2.*((x(1)+(-1).*y(1)).^2+(x(2)+(-1).*y(2)).^2+(x(3)+(-1).*y(3)).^2)).* ...
                    eps.^4.*(x(1)+(-1).*y(1)).*(x(3)+(-1).*y(3));4.*exp(1).^((-1).*eps.^2.*(( ...
                    x(1)+(-1).*y(1)).^2+(x(2)+(-1).*y(2)).^2+(x(3)+(-1).*y(3)).^2)).*eps.^4.*(x(1)+( ...
                    -1).*y(1)).*(x(2)+(-1).*y(2)),exp(1).^((-1).*eps.^2.*((x(1)+(-1).*y(1)).^2+( ...
                    x(2)+(-1).*y(2)).^2+(x(3)+(-1).*y(3)).^2)).*((-2).*eps.^2+4.*eps.^4.*(x(2)+( ...
                    -1).*y(2)).^2),4.*exp(1).^((-1).*eps.^2.*((x(1)+(-1).*y(1)).^2+(x(2)+(-1) ...
                    .*y(2)).^2+(x(3)+(-1).*y(3)).^2)).*eps.^4.*(x(2)+(-1).*y(2)).*(x(3)+(-1).*y(3)); ...
                    4.*exp(1).^((-1).*eps.^2.*((x(1)+(-1).*y(1)).^2+(x(2)+(-1).*y(2)).^2+(x(3)+( ...
                    -1).*y(3)).^2)).*eps.^4.*(x(1)+(-1).*y(1)).*(x(3)+(-1).*y(3)),4.*exp(1).^(( ...
                    -1).*eps.^2.*((x(1)+(-1).*y(1)).^2+(x(2)+(-1).*y(2)).^2+(x(3)+(-1).*y(3)).^2)) ...
                    .*eps.^4.*(x(2)+(-1).*y(2)).*(x(3)+(-1).*y(3)),exp(1).^((-1).*eps.^2.*(( ...
                    x(1)+(-1).*y(1)).^2+(x(2)+(-1).*y(2)).^2+(x(3)+(-1).*y(3)).^2)).*((-2).* ...
                    eps.^2+4.*eps.^4.*(x(3)+(-1).*y(3)).^2)];

    i=0;
    for N = 5:5:50
        geteps = @(n) -0.596239 + 0.113994*n;
        epsilon = geteps(N);
        X = getMEPoints(N);
        W = X(:,4);
        X = X(:,1:3);

        % Rotate X through by a small angle
        t=0.5;
        theta = [1 0 0;0 cos(t) -sin(t);0 sin(t) cos(t)];
        for i = 1:(N+1)^2
            X(i,:) = (theta*X(i,:)')';
        end

        % Div-free VFs can be given by curls of scalars.  Just use Qx*grad(u) =
        % curl_T(u) on the sphere.

        % Curl-free VFs

        % Test field 1, div-free component
        U1div = [(-X(:,2) + X(:,3)) (X(:,1) - X(:,3)) (-X(:,1) + X(:,2))];
        % Test field 1, curl-free component
        U1crl = [1-X(:,1).*(X(:,1) + X(:,2) + X(:,3)),1-X(:,2).*(X(:,1) + X(:,2) + X(:,3)),1-X(:,3).*(X(:,1) + X(:,2) + X(:,3))];

        % Test field 2
        U2crl = [(-2).*exp(1).^X(:,3).*((-1)+X(:,1).^2).*cos(2.*X(:,1))+((-2)+2.*X(:,1).^2+(-1).*exp(1).^X(:,3).*X(:,1).*X(:,3)).*sin(2.*X(:,1)),(-1).*X(:,2).*(2.*exp(1).^X(:,3).*X(:,1).*cos(2.*X(:,1))+((-2).*X(:,1)+exp(1).^X(:,3).*X(:,3)).*sin(2.*X(:,1))),(-2).*exp(1).^X(:,3).*X(:,1).*X(:,3).*cos(2.*X(:,1))+(2.*X(:,1).*X(:,3)+(-1).*exp(1).^X(:,3).*((-1)+X(:,3).^2)).*sin(2.*X(:,1))];
        U2div = [(-1).*exp(1).^X(:,3).*X(:,2).*sin(2.*X(:,1)),(-2).*exp(1).^X(:,3).*X(:,3).*cos(2.*X(:,1))+(exp(1).^X(:,3).*X(:,1)+2.*X(:,3)).*sin(2.*X(:,1)),2.*X(:,2).*(exp(1).^X(:,3).*cos(2.*X(:,1))+(-1).*sin(2.*X(:,1)))];
        
        % Test field 3
        %U3 = [X(:,3) -exp(X(:,1)).*X(3,:), -X(1,:) + exp(X(1,:)).*X(2,:)];

        % Run the divergence-free test
        [maxerr l2err kappa] = testHelmHodge(X, W, U2div, U2crl, HGA, epsilon);

        disp([maxerr l2err])
        j = j+1;
        errinfmat(j) = maxerr;
        err2mat(j)   = l2err;
        kappamat(j)  = kappa;
        epsmat(j)    = epsilon;

    end